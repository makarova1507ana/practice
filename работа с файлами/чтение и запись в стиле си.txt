#include <fstream>          //Для работы с файлами
#include <iostream>         //Для работы с клавиатурой и монитором
 
using namespace std;
 
int main() {
 
	const char *PATH = "C://MyFiles//2.txt";
 
	const int N = 256;    //максимальная длина строки S
	char S[N] = {};       //Строка, записываемая в файл
 
	unsigned short ERROR = 0;  //Это переменная для отслеживания ошибки
	ofstream f1;    //f1 у нас воплощает сам файл, с которого будем читать
	ifstream f2;     //f2 то же самое воплощение, но для записи
 
	unsigned short count = 0;    //Это счётчик значений, прочитанных из файла
	unsigned short select;       //Это переменная для выбора, будем делать мини-меню
 
	cout << "1. Read file" << endl;
	cout << "2. write file" << endl;
 
	(cin >> select).get();
 
 
	if (2 == select) {
		f1.open(PATH);        //Если выбрали 2, то записываем
		if (f1.is_open()) {  //Если воплощение файла засуществовало (т. е. если файл открылся), то выполняем блок действий
			for (int i = 0; i< 10; i++) {
				cout << "S[" << i << "]: ";
				cin.getline(S, N);
				f1 << S << '\n';
			};
		}
		else {
			ERROR = 1;     //Если воплощение файла не засуществовало, то обозначаем это
		}
 
		f1.close();
 
	} //end if 2 == select
	else if (1 == select) {
		cout << "\n===========\nstart read\n===========\n";
		f2.open(PATH);
		if (f2.is_open()) {  //Если наша программа смогла открыть файл, то выполняеи блок действий
 
			while (f2.getline(S, N)) { //Пока ввод успешен и не достигнут конец файла, читаем из файла данные
				cout << S << '\n';
				count++;
			}
 
			if (!f2.eof()) {       //Если НЕ достигнут конец файла, то выполняем блок действий
				if (f2.fail()) {
					ERROR = 2;      //Если считываемое значение не соответствует типу принимающего значение
				}
				else {
					ERROR = 3;      //Обозначаем неизвестную ошибку
				}
			}
 
		}
		else {
			ERROR = 1;      //1 будет обозначать, что наша программа файл открыть не смогла
		}
		f2.close();
		cout << "\n===========\nend read\n===========\n";
	}
 
 
	switch (ERROR) {
	case 1: cout << "file no opened\n"; break;              //Обозначаем, что файл не открылся
	case 2: cout << "file corrupted\n"; break;              //Обозначаем, что файл не открылся
	case 3: cout << "unknown error\n";  break;              //Обозначаем, что ошибка неопознана
	}
 
 
	if (!ERROR) {        //Если не произошло ошибки, то выполняет блок действий
						 //тут можно работать с массивом, заполненным из файла, например
		if (!count) cout << "Empty file\n";     //Если ошибок не возникло, то скорее всего файл пустой
		cout << "finished\n";
		cout << "read " << count << "value" << '\n';			//было прочитано count значений
	}
 
	cin.get();
 
}